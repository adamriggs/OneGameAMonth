// com.adam.utils.Sprite3DBatch// Adam Riggs//package com.app.view{	import com.adam.events.MuleEvent;	import com.adam.utils.AppData;	import com.adobe.utils.AGALMiniAssembler;	import com.adobe.utils.PerspectiveMatrix3D;	import com.greensock.TweenLite;		import flash.display.Sprite;	import flash.display3D.Context3D;	import flash.display3D.Context3DBlendFactor;	import flash.display3D.Context3DProgramType;	import flash.display3D.Context3DVertexBufferFormat;	import flash.display3D.IndexBuffer3D;	import flash.display3D.Program3D;	import flash.display3D.VertexBuffer3D;	import flash.events.*;	import flash.geom.Matrix3D;	import flash.geom.Point;		import org.robotlegs.mvcs.Context;
		public class Sprite3DBatch {				//vars		protected var _spriteCount:uint;		protected var _vpWidth:uint;		protected var _vpHeight:uint;				protected var _vertexStart:uint;		protected var _vertexCount:uint;		protected var _vertexSize:uint;				protected var _uvStart:uint;		protected var _uvCount:uint;		protected var _uvSize:uint;				protected var _indexStart:uint;		protected var _indexCount:uint;				protected var _vertexShaderCode:String;		protected var _fragmentShaderCode:String;				protected var _aspect:Number;		protected var _zNear:Number;		protected var _zFar:Number;		protected var _fov:Number;				//objects		private var appData:AppData=AppData.instance;		protected var _context3D:Context3D;		protected var _program3D:Program3D;		protected var _vertexBuffer:VertexBuffer3D;		protected var _uvBuffer:VertexBuffer3D;		protected var _indexBuffer:IndexBuffer3D;		protected var _vertexShader:AGALMiniAssembler;		protected var _fragmentShader:AGALMiniAssembler;		protected var _projectionTransform:PerspectiveMatrix3D;		protected var _rotationMatrix:Matrix3D;				protected var _spriteSheet:SpriteSheet;		protected var _vertices:Vector.<Number>;		protected var _indices:Vector.<uint>;		protected var _uvs:Vector.<Number>;		protected var _sprites:Vector.<Sprite3D>;				//const		public const NAME:String="sprite3DBatch";		public const RETURNTYPE:String=NAME;				public function Sprite3DBatch(ss:SpriteSheet, cntxt:Context3D){			_spriteSheet=ss;			_context3D=cntxt;						init();		}		//*****Initialization Routines				public function init():void{			debug("init()");						initVars();			initEvents();			initObjs();		}				private function initVars():void{			_spriteCount=3000;						_vpWidth=10;			_vpHeight=10;						_vertexStart=0;			_vertexSize=3;			_vertexCount=(_spriteCount*12)/_vertexSize;						_uvStart=0;			_uvSize=2;			_uvCount=(_spriteCount*8)/_uvSize;						_indexStart=0;			_indexCount=_spriteCount*6;						//shader opcode			_vertexShaderCode=				//				"m44 op, va0, vc0\n" + // pos to clipspace				//				"mov v0, va1.xy\n" + // copy uv				//				"mov v0.z, va0.z";				"dp4 op.x, va0, vc0 \n"+ // transform from stream 0 to output clipspace				"dp4 op.y, va0, vc1 \n"+ // do the same for the y coordinate				"mov op.z, vc2.z    \n"+ // we don't need to change the z coordinate				"mov op.w, vc3.w    \n"+ // unused, but we need to output all data				"mov v0, va1.xy     \n"+ // copy UV coords from stream 1 to fragment program				"mov v0.z, va0.z    \n"  // copy alpha from stream 0 to fragment program						//fragment opcode			_fragmentShaderCode=				"tex ft0, v0, fs0 <2d,clamp,linear,mipnearest>\n" +				"mul ft0, ft0, v0.zzzz\n" + // multiply by the alpha transparency				"mov oc, ft0";						//perspective			_aspect=4/3;			_zNear=.1;			_zFar=1000;			_fov=45*Math.PI/180;		}				private function initEvents():void{			appData.eventManager.listen(NAME, onSprite3DBatch);		}				private function initObjs():void{			_sprites=new Vector.<Sprite3D>;			_vertices=new Vector.<Number>;			_indices=new Vector.<uint>;			_uvs=new Vector.<Number>;						 var i:uint;			 var sp:Sprite3D;			 			 for(i=0;i<_spriteCount;i++){				 sp=new Sprite3D();				 addSprite(sp);				 updateVertexData(sp);			 }			 			 //go to sprite3dbatch			 _vertexShader=new AGALMiniAssembler(false);			 _vertexShader.assemble(Context3DProgramType.VERTEX,_vertexShaderCode);			 if(_vertexShader.error){				 debug("_vertexShader.error=="+_vertexShader.error);			 }			 			 _fragmentShader=new AGALMiniAssembler(false);			 _fragmentShader.assemble(Context3DProgramType.FRAGMENT,_fragmentShaderCode);			 if(_fragmentShader.error){				 debug("_fragmentShader.error=="+_fragmentShader.error);			 }			 			 			 //go to sprite3dbatch			 _projectionTransform=new PerspectiveMatrix3D();			 _projectionTransform.perspectiveFieldOfViewLH(_fov,_aspect,_zNear,_zFar);			 			 			 //go to sprite3dbatch			 _vertexBuffer=_context3D.createVertexBuffer(_vertexCount, _vertexSize);			 _vertexBuffer.uploadFromVector(_vertices,_vertexStart,_vertexCount);			 			 _uvBuffer=_context3D.createVertexBuffer(_uvCount, _uvSize);			 _uvBuffer.uploadFromVector(_uvs, _uvStart, _uvCount);			 			 _indexBuffer=_context3D.createIndexBuffer(_indexCount);			 _indexBuffer.uploadFromVector(_indices,_indexStart,_indexCount);			 			 _program3D=_context3D.createProgram();			 _program3D.upload(_vertexShader.agalcode,_fragmentShader.agalcode);			 		}		//*****Core Functionality				public function addSprite(sp:Sprite3D):void{			//debug("addSprite()");						sp.id=_sprites.length;			_sprites.push(sp);			sp.texCount=_spriteSheet.texCount;			sp.texSize=_spriteSheet.texSize;						sp.pos=new Point((Math.random()*_vpWidth)-(_vpWidth/2), (Math.random()*_vpHeight)-(_vpHeight/2));			//sp.pos=new Point(100, (Math.random()*_vpHeight)-(_vpHeight/2));			sp.tex=_spriteSheet.getRandomAnimation();						//sp.speedX=(Math.random()*.1)-.1;			//sp.speedX=-.07;			//sp.speedY=(Math.random()*.1)-0;			sp.rotation=15-(Math.random()*30);						_vertices.push(0,0,1,0,0,1,0,0,1,0,0,1);  //placeholders						var spVertexIndex:uint=(sp.id*12)/3;			_indices.push(spVertexIndex,spVertexIndex+1,spVertexIndex+2,spVertexIndex,spVertexIndex+2,spVertexIndex+3);						var uv:Vector.<Number>=new Vector.<Number>();			uv=sp.nextTex;			_uvs.push(uv[0],uv[1],uv[2],uv[3],uv[4],uv[5],uv[6],uv[7]);		}				public function removeSprite(sp:Sprite3D):void{					}				public function updateAllUVs():void{			for(var i:uint=0;i<_sprites.length;i++){				updateUVData(_sprites[i]);			}		}				public function updateUVData(sp:Sprite3D):void{			var spUVStart:uint=sp.id*8;	//texCount*texSize			var tex:Vector.<Number>=new Vector.<Number>;			tex=sp.nextTex;						_uvs[spUVStart]   =tex[0];			_uvs[spUVStart+1] =tex[1];			_uvs[spUVStart+2] =tex[2];			_uvs[spUVStart+3] =tex[3];			_uvs[spUVStart+4] =tex[4];			_uvs[spUVStart+5] =tex[5];			_uvs[spUVStart+6] =tex[6];			_uvs[spUVStart+7] =tex[7];					}				public function updateAllVertices():void{			for(var i:uint=0;i<_sprites.length;i++){				updateVertexData(_sprites[i]);			}			//trace("*****");		}				public function updateVertexData(sp:Sprite3D):void{			//debug("updateVertexData()");			var spVertexStart:uint=sp.id*12;			//trace("sp.pos.x=="+sp.pos.x);						if(sp.pos.x<-7.5){sp.pos.x=7;}			if(sp.pos.x>7){sp.pos.x=-7.5;}			if(sp.pos.y<-6){sp.pos.y=6;}			if(sp.pos.y>6){sp.pos.y=-6;}			sp.pos.x+=sp.speedX;			sp.pos.y+=sp.speedY;			//trace("sp.pos.x=="+sp.pos.x);						var spW:uint=1;			var spH:uint=1;			var spX:Number=sp.pos.x;			var spY:Number=sp.pos.y;			var spDX:Number=sp.speedX;			var spDY:Number=sp.speedY;			var alpha:Number=sp.alpha;						_vertices[spVertexStart]   =spX-(spW/2);			_vertices[spVertexStart+1] =spY-(spH/2);			_vertices[spVertexStart+2] =alpha;						_vertices[spVertexStart+3] =spX-(spW/2);			_vertices[spVertexStart+4] =spY+(spH/2);			_vertices[spVertexStart+5] =alpha;						_vertices[spVertexStart+6] =spX+(spW/2);			_vertices[spVertexStart+7] =spY+(spH/2);			_vertices[spVertexStart+8] =alpha;						_vertices[spVertexStart+9] =spX+(spW/2);			_vertices[spVertexStart+10]=spY-(spH/2);			_vertices[spVertexStart+11]=alpha;						//trace("_vertices[spVertexStart]=="+_vertices[spVertexStart]);			//trace("*****");					}				public function render():void{			if(!_context3D){				return;			}						_rotationMatrix=new Matrix3D();			//_rotationMatrix.appendRotation(getTimer()/10, Vector3D.Y_AXIS);			//			_rotationMatrix.appendRotation(getTimer()/40, Vector3D.X_AXIS);			//			_rotationMatrix.appendRotation(getTimer()/40, Vector3D.Z_AXIS);			_rotationMatrix.appendTranslation(0,0,12);			_rotationMatrix.append(_projectionTransform);						_context3D.clear(.5,.5,.5,1);						updateAllUVs();			updateAllVertices();						_uvBuffer=_context3D.createVertexBuffer(_uvCount, _uvSize);			_uvBuffer.uploadFromVector(_uvs, _uvStart, _uvCount);						_vertexBuffer=_context3D.createVertexBuffer(_vertexCount, _vertexSize);			_vertexBuffer.uploadFromVector(_vertices,_vertexStart,_vertexCount);						_context3D.setProgram(_program3D);			_context3D.setBlendFactors(Context3DBlendFactor.ONE, Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA);			_context3D.setProgramConstantsFromMatrix(Context3DProgramType.VERTEX,0,_rotationMatrix,true);			_context3D.setTextureAt(0,_spriteSheet.texture);						_context3D.setVertexBufferAt(0,_vertexBuffer,0,Context3DVertexBufferFormat.FLOAT_3);			_context3D.setVertexBufferAt(1,_uvBuffer,0,Context3DVertexBufferFormat.FLOAT_2);						_context3D.drawTriangles(_indexBuffer);		}				//*****Event Handlers				private function onSprite3DBatch(e:MuleEvent):void{			/*debug("onSprite3DBatch()");			debug("e.data.sender=="+e.data.sender);			debug("e.data.type=="+e.data.type);*/			switch(e.data.type){																default:					debug("onSprite3DBatch()");					debug("*type not found");					debug("e.data.sender=="+e.data.sender);					debug("e.data.type=="+e.data.type);				break;							}		}				//*****Gets and Sets				public function get vertices():Vector.<Number>{return _vertices;}		public function get indices():Vector.<uint>{return _indices;}		public function get uvs():Vector.<Number>{return _uvs;}				public function get indexStart():uint{return _indexStart;}		public function get indexCount():uint{return _indexCount;}		public function get vertexStart():uint{return _vertexStart;}		public function get vertexCount():uint{return _vertexCount;}		public function get vertexSize():uint{return _vertexSize;}				public function get uvStart():uint{return _uvStart;}		public function get uvCount():uint{return _uvCount;}		public function get uvSize():uint{return _uvSize;}				//*****Utility Functions				//**debug		private function debug(str:String):void{			appData.debug(NAME,str);		}				}//end class}//end package